# -*- coding: utf-8 -*-
"""VGG16_encoder_decoder.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SwpEwtoxX_NKTTpnSmGmJB4-U93QRVKV
"""

import warnings
warnings.filterwarnings('ignore')

import os
import patoolib
import os
import pandas as pd
import cv2 as cv
import numpy as np

from tqdm import tqdm
from matplotlib import pyplot as plt
from sklearn.model_selection import train_test_split

import tensorflow as tf
import imgaug.augmenters as iaa
import segmentation_models as sm

from tensorflow.keras.models import Model
from segmentation_models import Unet
from segmentation_models.metrics import iou_score

# sm.set_framework('tf.keras')
tf.keras.backend.set_image_data_format('channels_last')

os.environ['TF_FORCE_GPU_ALLOW_GROWTH'] = 'true'

project_path ='C:/Users/azmin/Downloads/Deep_globe_road_extraction/'

file_path = 'C:/Users/azmin/Downloads/Deepglobe2/metadata.csv'
df = pd.read_csv(filepath_or_buffer=file_path)

train_data = df[df['split'] == 'train3']
valid_data = df[df['split'] == 'valid2']
test_data = df[df['split'] == 'test2']

print(train_data)
class Dataset:
    def __init__(self, df):
        self.df = df

        self.w = 256
        self.h = 256

        # paths of images
        self.sat_images = self.df['sat_image_path'].to_list()

        # paths of masked images
        self.masks_fps = self.df['mask_path'].to_list()

        # labels for each class
        self.class_values = [0, 255]

    def __getitem__(self, i):
        # read data
        image = cv.imread('C:/Users/azmin/Downloads/Deepglobe2/' + self.sat_images[i], cv.IMREAD_UNCHANGED)
        image = cv.cvtColor(image, cv.COLOR_BGR2RGB)

        image_mask = cv.imread('C:/Users/azmin/Downloads/Deepglobe2/' + self.masks_fps[i], cv.IMREAD_UNCHANGED)
        image_mask = image_mask[:, :, 0]
        image_masks = [(image_mask == v) for v in self.class_values]
        image_mask = np.stack(image_masks, axis=-1).astype('float')

        return image, image_mask

    def __len__(self):
        return len(self.df)

class DataLoder(tf.keras.utils.Sequence):
    def __init__(self, dataset, batch_size=1, shuffle=False):
        self.dataset = dataset
        self.batch_size = batch_size
        self.shuffle = shuffle
        self.indexes = np.arange(len(dataset))

    def __getitem__(self, i):
        # collect batch data
        start = i * self.batch_size
        stop = (i + 1) * self.batch_size

        data = []
        for j in range(start, stop):
            data.append(self.dataset[j])

        batch = [np.stack(samples, axis=0) for samples in zip(*data)]

        return tuple(batch)

    def __len__(self):
        return len(self.indexes) // self.batch_size

    def on_epoch_end(self):
        if self.shuffle:
            self.indexes = np.random.permutation(self.indexes)


class ModelDesign:
    def __init__(self, train_data, model_name):
        self.width = 256
        self.height = 256

        self.train_data = train_data

        # base model from segmentation models
        self.model_name = model_name

    def _get_model(self):
        model = Unet(
            backbone_name=self.model_name,
            encoder_weights='imagenet',
            classes=2,
            activation='softmax',
            input_shape=(self.width, self.height, 3),
            encoder_freeze=True
        )
        return model

    def _plot_xy(self, x, y1, y2, yl, xl='epochs'):
        plt.plot(x, y1, label='train')
        plt.plot(x, y2, label='validation')
        plt.xlabel(xl)
        plt.ylabel(yl)
        plt.title('Train VS Validation')
        plt.legend()
        plt.show()
        return None

    def _plot_performance(self, tracker, epochs):
        x = list(range(1, epochs + 1))

        train_iou = tracker.history['iou_score']
        valid_iou = tracker.history['val_iou_score']

        train_loss = tracker.history['loss']
        valid_loss = tracker.history['val_loss']

        self._plot_xy(x=x, y1=train_iou, y2=valid_iou, yl='iou_score')
        self._plot_xy(x=x, y1=train_loss, y2=valid_loss, yl='loss')

        return None

    def train_model(self, batch_size=10, epochs=5, show_performance=True):
        from keras.callbacks import ModelCheckpoint, EarlyStopping

        model = self._get_model()

        # since the original validation data does not have masks
        # i am considering `1%` of `train_data` as the `custom_validation`
        # in order to keep track of the model's performance
        self.custom_train, self.custom_valid = train_test_split(self.train_data, test_size=0.1, random_state=42)

        train_dataset = Dataset(df=self.custom_train)
        valid_dataset = Dataset(df=self.custom_valid)

        train_dataloader = DataLoder(train_dataset, batch_size=batch_size, shuffle=True)
        valid_dataloader = DataLoder(valid_dataset, batch_size=batch_size, shuffle=True)

        optimizer = tf.keras.optimizers.Adam(0.001)

        # cce_dice_loss = categorical_crossentropy + dice_loss
        focal_loss = sm.losses.cce_dice_loss

        # callbacks
        model_path = project_path + 'models/{}.h5'.format(self.model_name)
        model_save_callback = ModelCheckpoint(
            filepath=model_path,
            save_weights_only=True,
            save_best_only=True,
            mode='max',
            monitor='val_iou_score'
        )
        early_stop_callback = EarlyStopping(monitor='val_iou_score', min_delta=0.01, patience=3, verbose=1)
        callbacks = [model_save_callback, early_stop_callback]

        model.compile(optimizer=optimizer, loss=focal_loss, metrics=[iou_score])

        if not os.path.isfile(path=model_path):
            tracker = model.fit(
                x=train_dataloader,
                steps_per_epoch=len(train_dataloader),
                epochs=epochs,
                validation_data=valid_dataloader,
                callbacks=callbacks
            )
            model.load_weights(model_path)

            if show_performance:
                self._plot_performance(tracker=tracker, epochs=len(tracker.history['iou_score']))

        else:
            print('Model is already trained and is present in directory.')
            model.load_weights(model_path)

        return model

    def plot_custom_valid_performance(self, model, n=10):
        vdata = self.custom_valid.head(n)
        h = self.height
        w = self.width

        # paths of images
        images_fps = vdata['sat_image_path'].to_list()
        # paths of masked images
        masks_fps = vdata['mask_path'].to_list()

        for oimg, mimg in zip(images_fps, masks_fps):
            # original image
            simage = cv.imread('C:/Users/azmin/Downloads/Deepglobe2/' + oimg, cv.IMREAD_UNCHANGED)
            simage = cv.cvtColor(simage, cv.COLOR_BGR2RGB)

            # mask image
            mimage = cv.imread('C:/Users/azmin/Downloads/Deepglobe2/' + mimg, cv.IMREAD_UNCHANGED)

            # prediction
            predicted_image = model.predict(simage[np.newaxis, :, :, :])
            predicted_mask = tf.argmax(predicted_image, axis=-1)

            # titles
            image_title = oimg.split('/')[-1]
            mask_title = mimg.split('/')[-1]

            # plotting figure
            plt.figure(figsize=(15, 6))

            plt.subplot(131)
            plt.axis("off")
            plt.title(image_title)
            plt.imshow(simage)

            plt.subplot(132)
            plt.axis("off")
            plt.title(mask_title)
            plt.imshow(mimage)

            plt.subplot(133)
            plt.axis("off")
            plt.title("Prediction - {}".format(image_title))
            plt.imshow(predicted_mask[0], cmap='gray')

            plt.show()

        return None

    def extract_road_path(self, x, model, n=10):
        x_ = x.head(n)
        h = self.height
        w = self.width

        # paths of images
        images_fps = x_['sat_image_path'].to_list()
        # paths of masked images
        masks_fps = x_['mask_path'].to_list()

        for oimg, mimg in zip(images_fps, masks_fps):
            # original image
            image = cv.imread('C:/Users/azmin/Downloads/Deepglobe2/' + oimg, cv.IMREAD_UNCHANGED)
            image = cv.cvtColor(image, cv.COLOR_BGR2RGB)

            # prediction
            predicted_image = model.predict(image[np.newaxis, :, :, :])
            predicted_mask = tf.argmax(predicted_image, axis=-1)
            image_title = oimg.split('/')[-1]

            plt.figure(figsize=(10, 6))

            plt.subplot(121)
            plt.axis("off")
            plt.title(image_title)
            plt.imshow(image)

            plt.subplot(122)
            plt.axis("off")
            plt.title("Prediction - {}".format(image_title))
            plt.imshow(predicted_mask[0], cmap='gray')

            plt.show()

        return None




m = ModelDesign(train_data=train_data, model_name='vgg16')

model = m.train_model()


m.plot_custom_valid_performance(model=model)

m.extract_road_path(x=test_data, model=model)